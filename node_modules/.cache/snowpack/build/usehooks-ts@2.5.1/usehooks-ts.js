import { useState, useCallback, useLayoutEffect, useEffect, useRef, useReducer, useMemo } from 'react';

function useBoolean(defaultValue) {
    const [value, setValue] = useState(!!defaultValue);
    const setTrue = useCallback(() => setValue(true), []);
    const setFalse = useCallback(() => setValue(false), []);
    const toggle = useCallback(() => setValue(x => !x), []);
    return { value, setValue, setTrue, setFalse, toggle };
}

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

function useEventListener(eventName, handler, element) {
    const savedHandler = useRef(handler);
    useIsomorphicLayoutEffect(() => {
        savedHandler.current = handler;
    }, [handler]);
    useEffect(() => {
        const targetElement = element?.current || window;
        if (!(targetElement && targetElement.addEventListener)) {
            return;
        }
        const eventListener = event => savedHandler.current(event);
        targetElement.addEventListener(eventName, eventListener);
        return () => {
            targetElement.removeEventListener(eventName, eventListener);
        };
    }, [eventName, element]);
}

function useClickAnyWhere(handler) {
    useEventListener('click', event => {
        handler(event);
    });
}

function useCopyToClipboard() {
    const [copiedText, setCopiedText] = useState(null);
    const copy = async (text) => {
        if (!navigator?.clipboard) {
            console.warn('Clipboard not supported');
            return false;
        }
        try {
            await navigator.clipboard.writeText(text);
            setCopiedText(text);
            return true;
        }
        catch (error) {
            console.warn('Copy failed', error);
            setCopiedText(null);
            return false;
        }
    };
    return [copiedText, copy];
}

function useCounter(initialValue) {
    const [count, setCount] = useState(initialValue || 0);
    const increment = () => setCount(x => x + 1);
    const decrement = () => setCount(x => x - 1);
    const reset = () => setCount(initialValue || 0);
    return {
        count,
        increment,
        decrement,
        reset,
        setCount,
    };
}

function useInterval(callback, delay) {
    const savedCallback = useRef(callback);
    useIsomorphicLayoutEffect(() => {
        savedCallback.current = callback;
    }, [callback]);
    useEffect(() => {
        if (!delay && delay !== 0) {
            return;
        }
        const id = setInterval(() => savedCallback.current(), delay);
        return () => clearInterval(id);
    }, [delay]);
}

function useCountdown({ seconds, interval, isIncrement, }) {
    const { count, increment, decrement, reset: resetCounter, } = useCounter(seconds);
    const { value: running, setTrue: start, setFalse: stop } = useBoolean(false);
    const reset = () => {
        stop();
        resetCounter();
    };
    useInterval(isIncrement ? increment : decrement, running ? interval : null);
    return [count, { start, stop, reset }];
}

function useLocalStorage(key, initialValue) {
    const readValue = useCallback(() => {
        if (typeof window === 'undefined') {
            return initialValue;
        }
        try {
            const item = window.localStorage.getItem(key);
            return item ? parseJSON(item) : initialValue;
        }
        catch (error) {
            console.warn(`Error reading localStorage key “${key}”:`, error);
            return initialValue;
        }
    }, [initialValue, key]);
    const [storedValue, setStoredValue] = useState(readValue);
    const setValueRef = useRef();
    setValueRef.current = value => {
        if (typeof window == 'undefined') {
            console.warn(`Tried setting localStorage key “${key}” even though environment is not a client`);
        }
        try {
            const newValue = value instanceof Function ? value(storedValue) : value;
            window.localStorage.setItem(key, JSON.stringify(newValue));
            setStoredValue(newValue);
            window.dispatchEvent(new Event('local-storage'));
        }
        catch (error) {
            console.warn(`Error setting localStorage key “${key}”:`, error);
        }
    };
    const setValue = useCallback(value => setValueRef.current?.(value), []);
    useEffect(() => {
        setStoredValue(readValue());
    }, []);
    const handleStorageChange = useCallback(() => {
        setStoredValue(readValue());
    }, [readValue]);
    useEventListener('storage', handleStorageChange);
    useEventListener('local-storage', handleStorageChange);
    return [storedValue, setValue];
}
function parseJSON(value) {
    try {
        return value === 'undefined' ? undefined : JSON.parse(value ?? '');
    }
    catch {
        console.log('parsing error on', { value });
        return undefined;
    }
}

function useMediaQuery(query) {
    const getMatches = (query) => {
        if (typeof window !== 'undefined') {
            return window.matchMedia(query).matches;
        }
        return false;
    };
    const [matches, setMatches] = useState(getMatches(query));
    function handleChange() {
        setMatches(getMatches(query));
    }
    useEffect(() => {
        const matchMedia = window.matchMedia(query);
        handleChange();
        if (matchMedia.addListener) {
            matchMedia.addListener(handleChange);
        }
        else {
            matchMedia.addEventListener('change', handleChange);
        }
        return () => {
            if (matchMedia.removeListener) {
                matchMedia.removeListener(handleChange);
            }
            else {
                matchMedia.removeEventListener('change', handleChange);
            }
        };
    }, [query]);
    return matches;
}

function useIsFirstRender() {
    const isFirst = useRef(true);
    if (isFirst.current) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
}

function useUpdateEffect(effect, deps) {
    const isFirst = useIsFirstRender();
    useEffect(() => {
        if (!isFirst) {
            return effect();
        }
    }, deps);
}

const COLOR_SCHEME_QUERY = '(prefers-color-scheme: dark)';
function useDarkMode(defaultValue) {
    const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY);
    const [isDarkMode, setDarkMode] = useLocalStorage('usehooks-ts-dark-mode', defaultValue ?? isDarkOS ?? false);
    useUpdateEffect(() => {
        setDarkMode(isDarkOS);
    }, [isDarkOS]);
    return {
        isDarkMode,
        toggle: () => setDarkMode(prev => !prev),
        enable: () => setDarkMode(true),
        disable: () => setDarkMode(false),
    };
}

function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = useState(value);
    useEffect(() => {
        const timer = setTimeout(() => setDebouncedValue(value), delay || 500);
        return () => {
            clearTimeout(timer);
        };
    }, [value, delay]);
    return debouncedValue;
}

function useEffectOnce(effect) {
    useEffect(effect, []);
}

function useElementSize() {
    const [ref, setRef] = useState(null);
    const [size, setSize] = useState({
        width: 0,
        height: 0,
    });
    const handleSize = useCallback(() => {
        setSize({
            width: ref?.offsetWidth || 0,
            height: ref?.offsetHeight || 0,
        });
    }, [ref?.offsetHeight, ref?.offsetWidth]);
    useEventListener('resize', handleSize);
    useIsomorphicLayoutEffect(() => {
        handleSize();
    }, [ref?.offsetHeight, ref?.offsetWidth]);
    return [setRef, size];
}

function useFetch(url, options) {
    const cache = useRef({});
    const cancelRequest = useRef(false);
    const initialState = {
        error: undefined,
        data: undefined,
    };
    const fetchReducer = (state, action) => {
        switch (action.type) {
            case 'loading':
                return { ...initialState };
            case 'fetched':
                return { ...initialState, data: action.payload };
            case 'error':
                return { ...initialState, error: action.payload };
            default:
                return state;
        }
    };
    const [state, dispatch] = useReducer(fetchReducer, initialState);
    useEffect(() => {
        if (!url)
            return;
        const fetchData = async () => {
            dispatch({ type: 'loading' });
            if (cache.current[url]) {
                dispatch({ type: 'fetched', payload: cache.current[url] });
                return;
            }
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                const data = (await response.json());
                cache.current[url] = data;
                if (cancelRequest.current)
                    return;
                dispatch({ type: 'fetched', payload: data });
            }
            catch (error) {
                if (cancelRequest.current)
                    return;
                dispatch({ type: 'error', payload: error });
            }
        };
        void fetchData();
        return () => {
            cancelRequest.current = true;
        };
    }, [url]);
    return state;
}

function useHover(elementRef) {
    const [value, setValue] = useState(false);
    const handleMouseEnter = () => setValue(true);
    const handleMouseLeave = () => setValue(false);
    useEventListener('mouseenter', handleMouseEnter, elementRef);
    useEventListener('mouseleave', handleMouseLeave, elementRef);
    return value;
}

function useImageOnLoad() {
    const [isLoaded, setIsLoaded] = useState(false);
    const handleImageOnLoad = () => {
        setIsLoaded(true);
    };
    const css = {
        thumbnail: {
            visibility: isLoaded ? 'hidden' : 'visible',
            filter: 'blur(8px)',
            transition: 'visibility 0ms ease-out 500ms',
        },
        fullSize: {
            opacity: isLoaded ? 1 : 0,
            transition: 'opacity 500ms ease-in 0ms',
        },
    };
    return { handleImageOnLoad, css };
}

function useIntersectionObserver(elementRef, { threshold = 0, root = null, rootMargin = '0%', freezeOnceVisible = false, }) {
    const [entry, setEntry] = useState();
    const frozen = entry?.isIntersecting && freezeOnceVisible;
    const updateEntry = ([entry]) => {
        setEntry(entry);
    };
    useEffect(() => {
        const node = elementRef?.current;
        const hasIOSupport = !!window.IntersectionObserver;
        if (!hasIOSupport || frozen || !node)
            return;
        const observerParams = { threshold, root, rootMargin };
        const observer = new IntersectionObserver(updateEntry, observerParams);
        observer.observe(node);
        return () => observer.disconnect();
    }, [elementRef, JSON.stringify(threshold), root, rootMargin, frozen]);
    return entry;
}

function useIsClient() {
    const [isClient, setClient] = useState(false);
    useEffect(() => {
        setClient(true);
    }, []);
    return isClient;
}

function useIsMounted() {
    const isMounted = useRef(false);
    useEffect(() => {
        isMounted.current = true;
        return () => {
            isMounted.current = false;
        };
    }, []);
    return useCallback(() => isMounted.current, []);
}

function useLockedBody(initialLocked = false) {
    const [locked, setLocked] = useState(initialLocked);
    useIsomorphicLayoutEffect(() => {
        if (!locked) {
            return;
        }
        const originalOverflow = document.body.style.overflow;
        const originalPaddingRight = document.body.style.paddingRight;
        document.body.style.overflow = 'hidden';
        const root = document.getElementById('___gatsby');
        const scrollBarWidth = root ? root.offsetWidth - root.scrollWidth : 0;
        if (scrollBarWidth) {
            document.body.style.paddingRight = `${scrollBarWidth}px`;
        }
        return () => {
            document.body.style.overflow = originalOverflow;
            if (scrollBarWidth) {
                document.body.style.paddingRight = originalPaddingRight;
            }
        };
    }, [locked]);
    useEffect(() => {
        if (locked !== initialLocked) {
            setLocked(initialLocked);
        }
    }, [initialLocked]);
    return [locked, setLocked];
}

function useMap(initialState = new Map()) {
    const [map, setMap] = useState(new Map(initialState));
    const actions = {
        set: useCallback((key, value) => {
            setMap(prev => {
                const copy = new Map(prev);
                copy.set(key, value);
                return copy;
            });
        }, []),
        setAll: useCallback(entries => {
            setMap(() => new Map(entries));
        }, []),
        remove: useCallback(key => {
            setMap(prev => {
                const copy = new Map(prev);
                copy.delete(key);
                return copy;
            });
        }, []),
        reset: useCallback(() => {
            setMap(() => new Map());
        }, []),
    };
    return [map, actions];
}

function useOnClickOutside(ref, handler, mouseEvent = 'mousedown') {
    useEventListener(mouseEvent, event => {
        const el = ref?.current;
        if (!el || el.contains(event.target)) {
            return;
        }
        handler(event);
    });
}

function useReadLocalStorage(key) {
    const readValue = useCallback(() => {
        if (typeof window === 'undefined') {
            return null;
        }
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        }
        catch (error) {
            console.warn(`Error reading localStorage key “${key}”:`, error);
            return null;
        }
    }, [key]);
    const [storedValue, setStoredValue] = useState(readValue);
    useEffect(() => {
        setStoredValue(readValue());
    }, []);
    const handleStorageChange = useCallback(() => {
        setStoredValue(readValue());
    }, [readValue]);
    useEventListener('storage', handleStorageChange);
    useEventListener('local-storage', handleStorageChange);
    return storedValue;
}

function useScreen() {
    const getScreen = () => {
        if (typeof window !== 'undefined' && window.screen) {
            return window.screen;
        }
        return undefined;
    };
    const [screen, setScreen] = useState(getScreen());
    function handleSize() {
        setScreen(getScreen());
    }
    useEventListener('resize', handleSize);
    useIsomorphicLayoutEffect(() => {
        handleSize();
    }, []);
    return screen;
}

function useScript(src) {
    const [status, setStatus] = useState(src ? 'loading' : 'idle');
    useEffect(() => {
        if (!src) {
            setStatus('idle');
            return;
        }
        let script = document.querySelector(`script[src="${src}"]`);
        if (!script) {
            script = document.createElement('script');
            script.src = src;
            script.async = true;
            script.setAttribute('data-status', 'loading');
            document.body.appendChild(script);
            const setAttributeFromEvent = (event) => {
                script?.setAttribute('data-status', event.type === 'load' ? 'ready' : 'error');
            };
            script.addEventListener('load', setAttributeFromEvent);
            script.addEventListener('error', setAttributeFromEvent);
        }
        else {
            setStatus(script.getAttribute('data-status'));
        }
        const setStateFromEvent = (event) => {
            setStatus(event.type === 'load' ? 'ready' : 'error');
        };
        script.addEventListener('load', setStateFromEvent);
        script.addEventListener('error', setStateFromEvent);
        return () => {
            if (script) {
                script.removeEventListener('load', setStateFromEvent);
                script.removeEventListener('error', setStateFromEvent);
            }
        };
    }, [src]);
    return status;
}

function useSsr() {
    const isDOM = typeof window !== 'undefined' &&
        window.document &&
        window.document.documentElement;
    return {
        isBrowser: isDOM,
        isServer: !isDOM,
    };
}

function useStep(maxStep) {
    const [currentStep, setCurrentStep] = useState(1);
    const canGoToNextStep = useMemo(() => currentStep + 1 <= maxStep, [currentStep, maxStep]);
    const canGoToPrevStep = useMemo(() => currentStep - 1 >= 1, [currentStep]);
    const setStep = useCallback(step => {
        const newStep = step instanceof Function ? step(currentStep) : step;
        if (newStep >= 1 && newStep <= maxStep) {
            setCurrentStep(newStep);
            return;
        }
        throw new Error('Step not valid');
    }, [maxStep, currentStep]);
    const goToNextStep = useCallback(() => {
        if (canGoToNextStep) {
            setCurrentStep(step => step + 1);
        }
    }, [canGoToNextStep]);
    const goToPrevStep = useCallback(() => {
        if (canGoToPrevStep) {
            setCurrentStep(step => step - 1);
        }
    }, [canGoToPrevStep]);
    const reset = useCallback(() => {
        setCurrentStep(1);
    }, []);
    return [
        currentStep,
        {
            goToNextStep,
            goToPrevStep,
            canGoToNextStep,
            canGoToPrevStep,
            setStep,
            reset,
        },
    ];
}

const COLOR_SCHEME_QUERY$1 = '(prefers-color-scheme: dark)';
function useTernaryDarkMode() {
    const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY$1);
    const [ternaryDarkMode, setTernaryDarkMode] = useLocalStorage('usehooks-ts-ternary-dark-mode', 'system');
    const [isDarkMode, setDarkMode] = useState(isDarkOS);
    useUpdateEffect(() => {
        if (ternaryDarkMode === 'system') {
            setDarkMode(isDarkOS);
        }
    }, [isDarkOS]);
    useEffect(() => {
        switch (ternaryDarkMode) {
            case 'light':
                setDarkMode(false);
                break;
            case 'system':
                setDarkMode(isDarkOS);
                break;
            case 'dark':
                setDarkMode(true);
                break;
        }
    }, [ternaryDarkMode, isDarkOS]);
    function toggleTernaryDarkMode() {
        const toggleDict = {
            light: 'system',
            system: 'dark',
            dark: 'light',
        };
        setTernaryDarkMode(prevMode => toggleDict[prevMode]);
    }
    return {
        isDarkMode,
        ternaryDarkMode,
        setTernaryDarkMode,
        toggleTernaryDarkMode,
    };
}

function useTimeout(callback, delay) {
    const savedCallback = useRef(callback);
    useIsomorphicLayoutEffect(() => {
        savedCallback.current = callback;
    }, [callback]);
    useEffect(() => {
        if (!delay && delay !== 0) {
            return;
        }
        const id = setTimeout(() => savedCallback.current(), delay);
        return () => clearTimeout(id);
    }, [delay]);
}

function useWindowSize() {
    const [windowSize, setWindowSize] = useState({
        width: 0,
        height: 0,
    });
    const handleSize = () => {
        setWindowSize({
            width: window.innerWidth,
            height: window.innerHeight,
        });
    };
    useEventListener('resize', handleSize);
    useIsomorphicLayoutEffect(() => {
        handleSize();
    }, []);
    return windowSize;
}

export { useBoolean, useClickAnyWhere, useCopyToClipboard, useCountdown, useCounter, useDarkMode, useDebounce, useEffectOnce, useElementSize, useEventListener, useFetch, useHover, useImageOnLoad, useIntersectionObserver, useInterval, useIsClient, useIsFirstRender, useIsMounted, useIsomorphicLayoutEffect, useLocalStorage, useLockedBody, useMap, useMediaQuery, useOnClickOutside, useReadLocalStorage, useScreen, useScript, useSsr, useStep, useTernaryDarkMode, useTimeout, useUpdateEffect, useWindowSize };
